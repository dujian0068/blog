## 白盒测试
1. 白盒测试（white-box-testing）又称之为透明盒测试（glass box testing）、结构测试（structural testing）等，软件测试的主要方法之一，也称之为结构测试、逻辑驱动测试或基于程序本身的测试。
目标是测试程序内部的结构或者运作，而不是程序本身的功能（黑盒测试）。
2. 在百合测试时，一程序语言的角度来设计测试案例。测试者了解待测试的程序本身的内部结构、算法等信息。测试者输入资料然后验证资料流在程序中的流通路径。并确定适当的输出结果。
3. 应用。白盒测试可以应用于单元测试、整合测试。
4. 白盒测试设计技术包括以下代码覆盖标准（覆盖率从低到高排序）：
    - 语句覆盖
    - 判定覆盖
    - 条件覆盖
    - 判定/条件覆盖
    - 条件组合覆盖
    - 路径覆盖
    

5. 测试原则
    - 保证被测模块中所有的路径至少被测试一次
    - 所有的逻辑值都要测试true和false两种情况
    - 检查程序中的内部数据结构是否有效
    - 检查上下边界及可操作范围内运行所有循环
    
6. 如何执行：
    1. 理解源代码
    2. 创建测试用例并执行
 
7. 优势：
    - 可以揭示隐藏的错误进行代码优化，可以消除可能存在的缺陷
    - 白盒测试可以轻松实现自动化
    - 从源代码层面测试提供了可追溯性，简化了软件改动带来的测试改动
    - 通常测试会涵盖所有的代码路径，测试的会更加彻底，单元测试可以做到100%的代码覆盖率

8. 劣势：
    - 白盒测试很复杂，因此测试人员必须有编程知识，根据测试层面的复杂性，白盒测试可能需要知识水平更高的人员
    - 白盒测试关注于当前已经存在软件，可能无法发现遗漏的功能
    - 在某些情况下，要测试程序中所有的可能情况是不现实的，因此会有一些未被测试的情况
    
## 静态白盒测试
静态测试是指不运行程序，通过人工对于程序和文档进行分析和检查，简单来说，静态白盒测试就是通过人工看代码找bug。

进行静态白盒测试的首要原因是今早发现软件缺陷，以找出动态黑盒测试难以发现或者隔离的软件缺陷。

进行静态白盒测试的另一个好处是为黑盒测试员在接受软件进行测试设计测试用例时提供思路

#### 代码审查清单
- 数据引用错误：数据引用错误，是指未经正确声明和初始化的变量，常量，数组，字符串或记录，而导致的软件缺陷
- 除了数据引用错误，还有数据声明错误、计算错误、比较错误、控制流程错误、子程序参数错误、输入输出错误。

## 动态白盒测试

动态白盒测试也称之为结构化测试。利用查看代码功能（作什么）和实现方式（怎么做）得到的信息来确定那些需要测试、哪些不需要测试、如何展开测试。

动态白盒测试包括以下四个部分：
- 直接测试底层函数、过程、子程序和库。
- 以完整程序的方式从顶层测试软件，但是根据对软件运行的了解调整测试用例
- 从软件获得读取变量和状态信息的访问权，以便确定测试与预期结果是否相符，同时，强制软件已正常测试难以实现的方式运行。
- 估算执行测试时“命中”的代码量和具体代码，然后调整测试，去掉多余的测试用例，补充一楼的用例。

## 数据覆盖

#### 数据流覆盖
数据流覆盖主要指在软件中完全跟踪一批数据。在单元测试中，数据仅仅通过了一个模块或者函数。同样的跟踪方式可能用于多个集成模块，甚至整个软件产品。如果在底层测试函数，就会使用调试器观察变量在程序运行时的数据，可以检查变量的中间值。
#### 次边界


## 代码覆盖
#### 语句覆盖
语句覆盖又称之为行覆盖、段覆盖、基本块覆盖，是最常见也最常用的一种覆盖方式，测的就是代码有没有执行到这里，每一个可以被执行的语句是否被执行到了。
简单地说就是设计一系列的测试用例，运行被测的程序，使得每一可执行语句至少被执行一次。当然为了减少工作量当然测试用例个数越少越好。

语句覆盖是最容易达到的覆盖，但是却是最弱的覆盖，尽管代码的行数的覆盖达到了100%，但是却没有考虑一些分支、组合、边界等问题。
```
public int div(int a, int b){
    return a/b;
}
```
像简单的除法，代码只有一行，也可以设计`a=10,b=1`一组简单的测试用例就可以达到100%的行覆盖，但是却隐藏着`b=0`异常。

#### 判定覆盖
判定覆盖是要设计足够多的测试用例，使得程序中的每一个判断至少获取一次true和一次false，即：使得流程图中的每一个真假分支各被执行一次。

特点：
1. 满足判定覆盖的测试用例一定满足语句覆盖
2. 对于判定的最终值进行度量，但是对于判定内部的每一个子表达式的取值未被考虑。

```
public void test(int a, int b,int x){
    if(a>1 and b=0) {
        //do 1
    }
    if(a=2 || b>2) {
        //do 2
    } 
}
```
例如上述语句`if(a>1 and b=0) `只需要判定整个`a>1 and b=0`执行结果为`true`或者`false`;

判定覆盖包含了语句覆盖
#### 条件覆盖
条件覆盖不仅使程序中的每个语句被执行了一次，而且使每个表达式中的每个条件都取到可能的结果。
以判定覆盖中的例子为例：
1. 首先有四个条件`a>1、b=0、a=2、b>2`
2. 为了达到条件覆盖需要设计足够的测试用例在`if(a>1 and b=0)`有`a>1 、a<=1、b=0、b!=0`
3. 在`if(a=2 || b>2)`有`a=2 、a!=2、b>2、b<=2`
4. 那么只需要`a=2、b=0`和`a=0、b=3`两组测试用例就可以满足

条件覆盖通常会比判定覆盖强，因为它使得每一个条件都取到两个不同的结果，而判定覆盖不保证这一点。
但是判定覆盖和条件覆盖不是包含关系

#### 判定/条件覆盖
判定条件覆盖是设计足够的测试用例，使得判断中每个条件的所有可能值至少执行一次，同时每个判定本身所有可能的结果至少执行一次，缺点是忽略了条件组合的情况。
对于条件覆盖所举的例子，是没有覆盖到`if(a=2 || b>2)`为false的情况的，因此需要加增一组测试用例`a=3、b=0`。
判定-条件覆盖包含了判定覆盖和条件覆盖

#### 条件组合覆盖
条件组合判定指得是：执行足够多的测试用例，使得每个判定中条件的各种可能出现的组合都至少出现一次，显然满足条件组合覆盖的测试用例一定满足判定覆盖、条件覆盖、判定/条件覆盖

#### 路径覆盖
路径覆盖指的是指测试时设计若干个测试用例，然后运行被测程序，要求覆盖到程序中所有可能的路径

路径覆盖显然是满足条件组合覆盖

#### 基本路径测试




